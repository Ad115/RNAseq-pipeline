#! /bin/env python3

"""
Quality check using FastQC
==========================

Author: Andrés García García @ May 2018

About the project
-----------------
NOTE: This is the first script in the pipeline of the project.

We are trying to detect if there are changes in the expression of
long non-coding RNAs between the left and right hemisphere of a mouse's
brain (telencephalon). For this, 3 samples where taken and sequenced using
RNAseq. For more information about RNAseq, see: 
https://galaxyproject.org/tutorials/rb_rnaseq/


The data
--------
The input data for the current script are the raw FASTQ files from the
RNAseq experiment.

    
The analysis
------------
We are basing our protocol on the instructions provided in:
https://davetang.org/muse/2017/10/25/getting-started-hisat-stringtie-ballgown/
https://www.biostars.org/p/207680/#207685

Procedure
---------
All the FASTQ files are already in a single folder (data/), so, we invoke
fastq on each of them.

Why do we need to generate another script? In order to get computing resources, we need to
enqueue the job through the SGE tasks system, this is done by specifying the task in a script.
That is the script that is generated here and submitted to the queue system through 'qsub' at 
the end of this file.

"""

import click
import textwrap
import subprocess
from typing import Union, List
from pathlib import Path


def get_output(command: Union[str, List[str]], **kwargs) -> str:
    """Execute a command through the shell, get the output as a string.
    """
    if isinstance(command, str) and not kwargs.get('shell'):
        command = command.split()
    bytes_output = subprocess.check_output(command, **kwargs)
    return bytes_output.decode('UTF-8')
# ---

def run(command: Union[str, List[str]], **kwargs) -> subprocess.CompletedProcess:
    """Execute a command through the shell. Doesn't capture output."""
    if isinstance(command, str) and not kwargs.get('shell'):
        command = command.split()
    return subprocess.run(command, **kwargs)
# ---


#### <<<<<< MAIN PROCEDURE >>>>>>> ####

# Command line interface
@click.command()

@click.option('--input_dir', '-i',
              help='The directory where the input files reside.'
                   ' Default: "./raw_data".')

@click.option('--output_dir', '-o',
              help='The directory where to output the results.'
                   ' Default: The same as the input directory.')

@click.option('--file_glob', '-f',
              help='A glob expression specifying the files to '
                   'analize from the input directory.'
                   ' Default: "*.fasta".')

@click.option('--ram', '-r', 
              help='RAM amount per job (in Gb). Default 8.')

def main(input_dir, output_dir, file_glob, ram):
    """Assemble the script with the commands for quality check and submit (qsub) it."""
    
    input_dir = Path(input_dir 
                         if input_dir 
                         else './raw_data').resolve()
    output_dir = Path(output_dir 
                          if output_dir 
                          else input_dir).resolve()
    
    file_glob = (file_glob 
                    if file_glob 
                    else '*.fastq')
    
    ram = ram if ram else 8
    
    print( 'Resolved parameters: \n'
          f'    Input directory: {input_dir}\n'
          f'    Output directory: {output_dir}\n'
          f'    File glob: {file_glob}\n'
          f'    RAM per process: {ram}')
    

    ## 1. --- Generate the commands.
    #          ... & search the files.
    input_files = (str(file) 
                       for file in input_dir.glob(file_glob))


    command_template = f"fastqc -o {output_dir} {{inputf}}"
    commands = [command_template.format(inputf=file) 
                    for file in input_files]

    commands_str = "\n    ".join( f"commands[{i+1}]='{s}'" 
                                  for i,s in enumerate(commands) )



    # 2. --- Assemble the script.
    #        Create the script that will launch the paralell jobs.

    python3_exec_path = get_output('which python3')

    script_contents = f"""\
    #! {python3_exec_path}

    #Run through this shell
    #$ -S {python3_exec_path}

    # Use current working directory
    #$ -cwd

    # Join stdout and stderr
    #$ -j y

    # If modules are needed, source modules environment (Do not delete the next line):
    #. /etc/profile.d/modules.sh

    # Name the job
    #$ -N quality_check

    # Pass environment
    #$ -V

    # Work with {ram}G RAM
    #$ -l vf={ram}G

    # Use as many jobs as needed
    #$ -t 1-{len(commands)}


    '''
    Quality check using FastQC
    --------------------------

    The current script was autogenerated with the 
    file `script.quality_check.py`, look there for documentation.

    '''

    import os
    import maya
    import subprocess
    from pathlib import Path


    # The commands to be executed
    commands = dict()
    {commands_str}

    # Fetch the job id
    task_id = int( os.environ['SGE_TASK_ID'] )

    # Fetch the command corresponding to the current job
    command = commands[task_id]


    # Execute the command
    print(f'Task {{task_id}}. Executing command @', maya.now(), ':', command, flush=True)

    subprocess.run(command.split()) # <-- Here it is executed, splitting is 
                                    #     necessary to pass the arguments 
                                    #     appropriately

    print(f'Task {{task_id}}. Finished execution @', maya.now(), flush=True)
    """
    # Remove indentation
    script_contents = textwrap.dedent(script_contents)
    
    
    
    # 3. --- Write the script to a file.
    
    script_name = 'script.autogenerated.quality_check_jobs.py'

    with open(script_name, 'w') as outf:
        outf.write(script_contents)


        
    # 4. -- Launch the job
    run(f"qsub {script_name}")
# ---



if __name__ == '__main__':
    # Command line interface
    main()